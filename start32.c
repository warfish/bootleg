#include <types.h>
#include <assert.h>
#include <stdlib.h>

#include "pci.h"

static void _putc(char c)
{
    __asm__ volatile("out %%al, %%dx" ::"a"(c), "d"(0x402):);
}

static void _puts(const char* s)
{
    while (*s != '\0') {
        _putc(*s++);
    }
}

static void _putline(void)
{
    _putc('\n');
}

static char _hex2char(uint8_t v)
{
    return (v <= 9 ? '0' + v : 'A' - 0xA + v);
}

static void _putx8(uint8_t v)
{
    _putc(_hex2char((v & 0xF0) >> 4));
    _putc(_hex2char(v & 0x0F));
}

static void _putx16(uint16_t v)
{
    __asm__ volatile("xchg %%al, %%ah" :"=a"(v) :"a"(v) :);
    
    _puts("0x");
    for (unsigned i = 0; i < 2; ++i) {
        _putx8(v & 0xFF);
        v >>= 8;
    }
}

static void _putx32(uint32_t v)
{
    __asm__ volatile("bswap %%eax" :"=a"(v) :"a"(v) :);
    
    _puts("0x");
    for (unsigned i = 0; i < 4; ++i) {
        _putx8(v & 0xFF);
        v >>= 8;
    }
}

static void _putul(unsigned long v)
{
    /* ULONG_MAX = 4294967295 */
    char buffer[10];
    buffer[9] = '\0';
    char* pbuf = &buffer[8];

    do {
        *pbuf-- = v % 10;
        v /= 10;
    } while (v);

    _puts(pbuf + 1);
}

void bzero(void* s, size_t n)
{
    __asm__ volatile("\
        xor     %%eax, %%eax    \t\n\
        rep     stosl           \t\n\
    "::"c"(n) :"memory");
}

void* memcpy(void* dest, const void* src, size_t n)
{
    uint32_t* pdest32 = (uint32_t*)dest;
    const uint32_t* psrc32 = (const uint32_t*)src;

    for (size_t i = 0; i < (n >> 2); ++i) {
        *pdest32++ = *psrc32++;
    }

    for (size_t i = 0; i < (n & 3); ++i) {
        *(uint8_t*)pdest32++ = *(uint8_t*)psrc32++;
    }

    return dest;
}

void _assert(const char* file, unsigned long line, const char* reason)
{
    _puts("Assertion \""); _puts(reason); _puts("\" failed at file ");
    _puts(file); _puts(" line "); _putul(line);
    _putline();

    abort();
}


/**
 * Exception frame record.
 * Generated by assembly code, order of fields is important.
 */
struct exception_frame32 {
    uint32_t edi;
    uint32_t esi;
    uint32_t ebp;
    uint32_t esp;
    uint32_t ebx;
    uint32_t edx;
    uint32_t ecx;
    uint32_t eax;
    uint32_t error_code;
    uint32_t eip;
    uint16_t cs;
    uint16_t _pad;
    uint32_t eflags;
};

void exception_handler(unsigned long num, struct exception_frame32* frame)
{
    _puts("Exception "); _putx16(num); _putline();
    _puts("CS: "); _putx16(frame->cs); _putline();
    _puts("EIP: "); _putx32(frame->eip); _putline();
    _puts("EFLAGS: "); _putx32(frame->eflags); _putline();
    _puts("Error code: "); _putx32(frame->error_code); _putline();
    _puts("EAX: "); _putx32(frame->eax); _putline();
    _puts("EBX: "); _putx32(frame->ebx); _putline();
    _puts("ECX: "); _putx32(frame->ecx); _putline();
    _puts("EDX: "); _putx32(frame->edx); _putline();
    _puts("EDI: "); _putx32(frame->edi); _putline();
    _puts("ESI: "); _putx32(frame->esi); _putline();
    _puts("EBP: "); _putx32(frame->ebp); _putline();
    _puts("ESP: "); _putx32(frame->esp); _putline();
}

static void enable_low_ram(void)
{
    uint32_t i440fx = pci_make_bdf(0, 0, 0);
    uint32_t pam02 = pci_read32(i440fx, 0x58);
    uint32_t pam36 = pci_read32(i440fx, 0x5C);

    pam02 |= 0x33333000; /* PAM0 starts at 0x59, avoid touching 0x58 */
    pam36 |= 0x33333333;

    pci_write32(i440fx, 0x58, pam02);
    pci_write32(i440fx, 0x5C, pam36);

    pam02 = pci_read32(i440fx, 0x58);
    pam36 = pci_read32(i440fx, 0x5C);

#ifdef DEBUG
    for (uint32_t* ptr = 0x000E0000; ptr < 0x000F0000; ++ptr) {
        *ptr = 0xEEEEEEEE;
    }

    for (uint32_t* ptr = 0x000F0000; ptr < 0x00100000; ++ptr) {
        *ptr = 0xFFFFFFFF;
    }
#endif
}

int main(void)
{
    enable_low_ram();
    _puts("low mem enabled"); _putline();

    return 0;
}

int _start(void)
{
    return main();
}
